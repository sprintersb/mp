#include "mp-gaussint.h"
#include "mp-mint.h"

#define DIAGNOSTIC_NO_FORMAT_CHECK
#include "diagnostic.h"

#include <utility>
#include <cstdlib>
#include <cassert>

bool GaussInt::
ComparePythagorean::operator () (const GaussInt& a, const GaussInt& b) const
{
    return a.cmp (b, mod_units_conjugation) < 0;
}

bool GaussInt::
CompareModuloUnits::operator () (const GaussInt& a, const GaussInt& b) const
{
    return a.cmp (b, mod_units) < 0;
}

GaussInt operator + (long i, const GaussInt& g) { return g + i; }
GaussInt operator - (long i, const GaussInt& g) { return (-g) + i; }
GaussInt operator * (long i, const GaussInt& g) { return g * i; }

GaussInt Int::operator + (const GaussInt& g) const { return g + (*this); }
GaussInt Int::operator - (const GaussInt& g) const { return (-g) + (*this); }
GaussInt Int::operator * (const GaussInt& g) const { return g * (*this); }

GaussInt GaussInt::operator / (const Self& a) const
{
    Self rem, q = divmod (a, rem);
    if (! rem.is_zero())
        error ("%s not divided by %s", to_str(), a.to_str());
    return q;
}

GaussInt GaussInt::operator / (const Int& a) const
{
    Self rem, q = divmod (Self (a), rem);
    if (! rem.is_zero())
        error ("%s not divided by %Zd", to_str(), a.mpz());
    return q;
}

GaussInt GaussInt::operator / (long a) const
{
    Self rem, q = divmod (Self (a), rem);
    if (! rem.is_zero())
        error ("%s not divided by %ld", to_str(), a);
    return q;
}

GaussInt GaussInt::operator / (const Int&) const;
GaussInt GaussInt::operator / (long) const;

void GaussInt::operator /= (const Self& a) { (*this) = (*this) / a; }
void GaussInt::operator /= (const Int& i) { (*this) = (*this) / i; }
void GaussInt::operator /= (long i) { (*this) = (*this) / i; }

GaussInt GaussInt::canonical (Canonical how) const
{
    switch (how)
    {
        default: assert (0);

        case mod_void:
            return *this;

        case mod_negation:
            return y_ < 0L ? -(*this) : (*this);

        case mod_conjugation:
            return y_ < 0L ? ~(*this) : (*this);

        case mod_units_conjugation:
            return x_.abscmp (y_) >= 0
                ? Self (x_.abs(), y_.abs())
                : Self (y_.abs(), x_.abs());

        case mod_units:
            switch ((x_ < 0L) + 2 * (y_ < 0L))
            {
                default: assert (0);
                case 0: return *this;
                case 1: return Self (y_, -x_);
                case 2: return Self (-y_, x_);
                case 3: return -(*this);
            }
    }
    assert (0);
}


// Starship <=> modulo Canonical.
int GaussInt::cmp (const Self& g, Canonical how) const
{
    Self a = this->canonical (how);
    Self b = g.canonical (how);
    int cx = a.x_.cmp (b.x_);
    int cy = a.y_.cmp (b.y_);

    return cx ? cx : cy;
}

void GaussInt::print() const
{
    char *str = to_str();
    printf ("%s", str);
    free (str);
}

char* GaussInt::to_str() const
{
    char *str, sign = "+-"[y_ < 0];

    if (is_natural())
        gmp_asprintf (&str, "%Zd", x_.mpz());
    else if (y_.abscmp (1) == 0)
        gmp_asprintf (&str, "(%Zd %c I)", x_.mpz(), sign);
    else
        gmp_asprintf (&str, "(%Zd %c I*%Zd)", x_.mpz(), sign , y_.abs().mpz());

    return str;
}

GaussInt GaussInt::pow (int expo) const
{
    if (expo < 0)
        error ("todo pow %d", expo);

    Int ex (expo);
    Self g (1);
    if (expo)
        for (int bitno = ex.msbit(); ; --bitno)
        {
            if (ex.bit (bitno))
                g *= *this;
            if (bitno == 0)
                break;
            g *= g;
        }
    
    return g;
}

std::ostream& operator << (std::ostream& ost, const GaussInt& a)
{
    a.print();
    return ost;
}


// 0 = All fine.
// 1 = Not prime.
// 2 = Does not factor.
GaussInt GaussInt::factor_integer_prime (const Int& p0, int *p_report)
{
    int dummy;
    int& kind = p_report ? *p_report : dummy;
    kind = 0;

    Int p = p0.abs();

    if (p < 2)
    {
        kind = 1;
        return Zero;
    }
    else if (p == 2)
    {
        kind = 0;
        return 1 + I;
    }
    else if (0 == p.is_probab_prime (30))
    {
        kind = 1;
        return Zero;
    }
    else if (p % 4 == 3)
    {
        kind = 2;
        return p;
    }

    // Prime ideal is generated by a = (p;0), b = (r/2;1) in canonical basis
    // with:
    //      r^2 = -4 mod p
    //      r   =  0 mod 2 
    //      0 < r < p  or  better  |r| <= (p-1) / 2.

    auto mp = MInt::make_modulus (p);
    MInt::SquareKind root_kind;
//out ("Here\n");
    Int r = MInt (mp, -4).sqrt (&root_kind).z();
    if (2 * r >= p)
        r -= p;
    if (r.is_odd())
        r = r < 0 ? r + p : r - p;

    auto aa = GaussInt (p, 0);
    auto bb = GaussInt (r/2, 1);

    auto ggt = aa.gcd(bb);

    assert (p == ggt.norm());
    return ggt;

#if 0
//out ("Here r = %Zd\n", r.mpz());

    auto ggt = aa.gcd(bb);
    Int bb_bb, aa_bb, lam;
    //int nn = 20;
    while (1)//--nn)
    {
//out ("aa = "); aa.print(); printf ("\n");
//out ("bb = "); bb.print(); printf ("\n");

        aa_bb = aa.sprod (bb);
        bb_bb = bb.sprod (bb);
        lam = aa_bb.round_div (bb_bb);
//        double d = (double) aa_bb / (double) bb_bb;
//out ("lam = %Zd = %.2f = %Zd / %Zd\n", lam.mpz(), d, aa_bb.mpz(), bb_bb.mpz());
        aa = aa - lam * bb;
//out ("aa' = "); aa.print(); printf ("\n");
        if (aa.norm() >= bb.norm())
            break;

        std::swap (aa, bb);
    }
//out ("short = "); bb.print(); printf ("\n");
//out ("norm = %Zd\n", bb.norm().mpz());

    GaussInt rem, q = ggt.divmod (bb, rem);
    assert (rem.is_zero());
    assert (q.is_unit());
    return bb;
#endif
}

auto GaussInt::round_div (const Self& d) const -> Self
{
    if (d.is_zero())
        error ("%s round_div 0", to_str());

    Self zz = (*this) * ~d;
    Self nn = d.norm(); // d * ~d;
    assert (nn.is_real());

    Int ni = nn.real();
    Int qx = zz.x().round_div (ni);
    Int qy = zz.y().round_div (ni);

    return Self (qx, qy);
}

auto GaussInt::divmod (const Self& d, Self& rem) const -> Self
{
    if (d.is_zero())
        error ("%s divmod 0", to_str());

    Self q = round_div (d);
    rem = (*this) - q * d;

    return q;
}

auto GaussInt::force_remove_factor (const Self& d) const -> Self
{
    Self rem, q = divmod (d, rem);
    return rem.is_zero() ? q : Zero;
}

auto GaussInt::operator % (const Self& d) const -> Self
{
    if (d.is_zero())
        error ("%s %% 0", to_str());

    Self rem;
    (void) divmod (d, rem);
    return rem;
}



auto GaussInt::next_prime () const -> Self
{
    Int n = is_complex() ? norm() : canonical(mod_units).real();
    Int p = n.next_prime();

    return p.mod(4) == 3
        ? Self (p, 0)
        : Self::factor_integer_prime (p).canonical(mod_units_conjugation);
}

auto GaussInt::gcd (const Self& bb) const -> Self
{
    Self a = *this, b = bb;
    
    while (! b.is_zero())
    {
        //std::cout << "gcd: " << a << ", " << b << std::endl;
        a = a % b;
        std::swap (a, b);
    }
    return a;
}

#include "mp-factor.h"

namespace
{

void add_powers (Factors<GaussInt>::Xs& xs, GaussInt& g, Factors<Int>::Xs& zs,
                 bool prim)
{
    GaussInt q;

    for (const auto& z : zs)
    {
        GaussInt p = prim
            ? GaussInt::factor_integer_prime (z, nullptr)
            : z;

        while (! (q = g.force_remove_factor (p)).is_zero())
        {
            xs.push_back (p.canonical (GaussInt::mod_negation));
            g = q;
        }

        if (p.is_real())
            continue;

        while (! (q = g.force_remove_factor (~p)).is_zero())
        {
            xs.push_back ((~p).canonical (GaussInt::mod_negation));
            g = q;
        }
    }
}

GaussInt add_powers (Factors<GaussInt>& gs, const GaussInt& g0, Factors<Int>& ps)
{
    GaussInt g = g0;

    add_powers (gs.primes_, g, ps.primes_, true);
    add_powers (gs.pseudo_primes_, g, ps.pseudo_primes_, true);
    add_powers (gs.composites_, g, ps.composites_, false);

    return g;
}

}; // ::anon

auto GaussInt::factor (int verbose) const -> Factors<Self>
{
    const Self& g0 = *this;
    assert (! this->is_zero());
    Factors<GaussInt> gs;
    gs.n_ = g0;
    gs.verbose_ = verbose;

    // g0 = g * t  with  t in Z maximal.
    Int t = ::gcd (g0.x(), g0.y());
    GaussInt g = g0 / t;

    GaussInt c = g.gcd (GaussInt (t));
    g /= c;
    GaussInt a = GaussInt (t) / c;

    if (gs.verbose_)
        out ("GaussInt: factoring common part %Zd + I*%Zd -> %Zd...\n",
             c.x().mpz(), c.y().mpz(), c.norm().mpz());
    Factors<Int>::Context ctx;
    ctx.verbose_ = gs.verbose_;
    Factors<Int> cs = ::factor (c.norm(), &ctx);
    if (gs.verbose_ && ! c.is_unit())
        std::cout << cs << std::endl;
    
    for (const auto& f : cs.powers_)
    {
        Int value = f.value();
        assert (t.mod (value) == 0L);
        t /= f.value();
    }

    std::cout << "GaussInt: " << a << " * " << c << " * " << g << std::endl;

    if (gs.verbose_)
        out ("GaussInt: factoring integral part %Zd...\n", t.mpz());
    Factors<Int> ts = ::factor (t, &ctx);
    if (gs.verbose_ && ! t.is_unit())
        std::cout << ts << std::endl;

    Int ng = g.norm();
    if (gs.verbose_)
        out ("GaussInt: factoring complex part %Zd + I*%Zd -> %Zd...\n",
             g.x().mpz(), g.y().mpz(), ng.mpz());
    Factors<Int> ngs = ::factor (ng, &ctx);
    if (gs.verbose_ && ! ng.is_unit())
        std::cout << ngs << std::endl;

    // Putting all together.
    g = add_powers (gs, g0, ts);
    g = add_powers (gs, g, ngs);
    g = add_powers (gs, g, cs);

    assert (g.is_unit());

    gs.set_powers();

    return gs;
}


// Split the common integral part of Prod NS and set POWERS to the
// prime ideals needed to solve the norm equation.
GaussInt GaussInt::
solve_norm_integral_part (const Factors<Int>& ns,
                          std::vector<Power<Self>>& powers, bool primitive)
{
    Self m = One;

    // Split into common factor M and complex primes.
    for (const auto& be : ns.powers_)
    {
        int expo = be.expo_;
        const Int& base = be.base_;
        switch ((long) base.mod (4))
        {
            default: assert (0);

            case 1:
            {
                Self q = factor_integer_prime (base);
                powers.push_back (Power<Self> (q, expo));
                break;
            }

            case 2:
                if (primitive && expo != 1)
                    return Zero;
                m *= (1 + I).pow (expo);
                break;

            case 3:
                if (primitive || expo % 2 == 1)
                    return Zero; // No solution.
                m *= base.pow (expo / 2);
                break;
        }
    }

    return m;
}

auto GaussInt::solve_norm (const Factors<Int>& ns, bool primitive)
    -> PythagoreanTriples
{
    if (!ns.is_fully_factored())
        error ("need all prime factors of %Zd to solve norm equation",
               ns.n_.mpz());

    PythagoreanTriples solutions;

    // Prime powers of complex primes except 1 + i.
    std::vector<Power<Self>> powers;

    // Prime powers of remaining primes or 0 if no solution exists.
    Self m = solve_norm_integral_part (ns, powers, primitive);

    if (m.is_zero())
        return solutions;

    std::vector<int> ex (powers.size(), 0);

    while (1)
    {
        // Regard EX as a k-digit number where k = primes.size() and the
        // significance of digit j is  1 + ex_j  where  ex_j is the power
        // or the j-th prime ideal p_j.  ex_j is the number of posiibilities
        // to build products of powers of  p_j  and of ~p_j  such that their
        // number is  ex_j.

        Self g = One;
        for (size_t j = 0; j < ex.size(); ++j)
        {
            const Self& base = powers[j].base_;
            int ex_j = powers[j].expo_;
            //out ("%d:%d[%d]__", ex[j], expo, expo - ex[j]);
            g *= base.pow (ex[j]) * (~base).pow (ex_j - ex[j]);
        }
        g = (m * g).canonical (mod_units_conjugation);
        if (!primitive || (g.is_unit() || !g.is_real()))
            solutions.insert (g);
        //out (" -> %s = %Zd\n", g.to_str(), g.norm().mpz());
next:;
        // Get the next EX's.  This is like increasing digits when counting
        // but taking care of the different significances.
        size_t i;
        for (i = 0; i < ex.size(); ++i)
        {
            ex[i] += primitive ? powers[i].expo_ : 1;
            if (ex[i] <= powers[i].expo_)
                break;

            ex[i] = 0;
        }

        if (i == ex.size())
            return solutions;

        // We have to factor out complex conjugation which does not contribute
        // new solutions.  To that end, the first prime-power factor that gets
        // the token is in charge of controlling that.
        for (int j = (int) ex.size() - 1; j >= 0; --j)
        {
            // Each ideal allows for  1 + ex_j  combinations of itself
            // with it's conjugate.  If their exponents equal out, their
            // product is real and thus the ideal cannot control conjugation.
            if (2 * ex[j] == powers[j].expo_)
                continue;
            else if (ex[j] > powers[j].expo_ / 2)
                goto next;
            else
                break;
        }
    }
    assert (0);
}


const GaussInt GaussInt::Zero { Int (0L) };
const GaussInt GaussInt::One  { Int (1L) };
const GaussInt GaussInt::I    { Int (0L), Int (1L) };

void GaussInt::Stat::print (FILE *fout, const char *fmt) const
{
    char s[100];
    double q = 0;
    if (n_total)
        q = 100.0 * n_prime_a_plus_b / n_total;
    sprintf (s, "%d / %d = %.1f%s", n_prime_a_plus_b, n_total, q,
             percent);
    fprintf (fout, fmt, s);
}

void GaussInt::Stat::operator += (const Stat& s)
{
    n_prime_a_plus_b += s.n_prime_a_plus_b;
    n_total += s.n_total;
}
